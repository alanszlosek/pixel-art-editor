<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pixels</title>

<style>
html {
    -webkit-text-size-adjust: 100%;
}
html,body,button,input,textarea,div,em,a {
    box-sizing: border-box;
    color: #636363;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1.0em;
    margin: 0;
    padding: 0;
}

button {
    background-color: #3372b3;
    border: 0;
    border-radius: .15em;
    color: #fff;
    cursor: pointer;
    display: inline-block;
    height: auto;
    line-height: 1.7em;
    padding: .3em 1.1em;
    text-align: center;
    vertical-align: middle;
    width: auto;
}
input, textarea {
    background-color: #f5f5f5; /*#fbfbfb;*/
    color: #636363;
    border-top: 0px;
    border-right: 0px;
    border-bottom: 1px solid #ccc;
    border-left: 0px;
    padding: 0.2em;
}
input {
    /* This is to gently nudge the input narrower in the tag list above addNote */
    min-width: 60px;
}
button.notice, #nav > div.notice {
    background-color: #ff7c39;
}
.success, button.save {
    background-color: #2084e9 !important;
    color: #fff;
}
.disabled {
    background-color: #ccc !important;
}
.smaller {
    padding: .3em;
}
:focus {
    outline: none;
}


.flex {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    margin: 0;
    width: auto;
}
.flex > * {
    flex: 1;
    padding-left:0;
}
.flex.one > * {
    flex: 1 1 100%;
}
.flex.three > div {
    flex: 1 1 33.3333%;
}
.flex.four > div {
    flex: 1 1 25%;
}
.flex.five > * {
    flex: 1 1 20%;
}
.flex.six > div {
    flex: 1 1 16.6666%;
}
.flex.seven > div {
    flex: 1 1 14.2857%;
}

.button.smaller {
    font-size: smaller; /*.75em;*/
}

.noscroll {
    overflow: hidden;
}
.overlay {
    background-color: #fff;
    bottom: 0;
    display: none;
    left: 0;
    overflow-y: scroll;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 2;
}
.container {
    margin-left: auto;
    margin-right: auto;
    max-width: 1000px;
}

.right {
    float: right;
}

.hidden {
    display: none;
}

.push {
    margin-bottom: 10px;
}


.main {

}


#nav {
    background-color: #fff;
    position: fixed;
    height: 40px;
    left: 0;
    top: 0;
    width: 100%;
}



#palette {
    display: grid;
    grid-template-columns: 10% 10% 10% 10% 10% 10% 10% 10% 10% 10% ;
}
#palette > div {
    height: 50px;
}
#palette > div.selected {
    border: 2px solid red;
}

div.controls {
    display: flex;
    margin-bottom: 10px;
}
div.controls > div {
    flex: 1;
    height: 40px;
    padding-top: 10px;
    text-align: center;
}

div.controls > div.selected {
    border-bottom: 3px solid black;
}

.controls > div.spacer, .flex > div.spacer {
    flex: 0 0 10px;
}

#canvas {
    border: 1px solid black;
    display: grid;
    width: 100%;
}
#canvas > div {
    width: 100%;
}
#canvas.grid > div {
    border: 1px solid black;
}

.brush {
    border: 1px solid black;
 
}
.brushType {
    background-color: #7cafc2;
    border-bottom: 3px solid #7cafc2;
}


</style>
</head>
<body id="body">

    <div style="display: grid; grid-template-columns: 60% 40%;">
        <div>
            <div id="canvas"></div>
        </div>
        <div style="padding-left: 40px;">
            <div id="controls">
                <div class="flex">
                    <div>Primary</div>
                    <div class="spacer"></div>
                    <div>Secondary</div>
                </div>
                <div class="controls">
                    <div class="brush" id="color1" style="background-color: yellow;"></div>
                    <div class="spacer"></div>
                    <div class="brush" id="color2"></div>
                </div>
                <div class="controls">
                    <div class="brushType selected" data-action="brushType" data-value="1">1px</div>
                    <div class="brushType" data-action="brushType" data-value="3">3px</div>
                    <div class="brushType" data-action="brushType" data-value="5">5px</div>
                    <div class="brushType" data-action="brushType" data-value="fill">Fill</div>
                    <div class="brushType" data-action="brushType" data-value="dropper">Dropper</div>
                </div>
                <div class="controls">
                    <div data-action="undo">Undo</div>
                    <div data-action="redo">Redo</div>
                    <div data-action="zoomOut">-</div>
                    <div data-action="zoomIn">+</div>
                    <div style="background-color: #a1b56c;" data-action="toggleGrid">Toggle Grid</div>
                </div>
            </div>

            <div id="palette"></div>
            <h2>Tiling Preview</h2>
            <div id="tiledPreview"></div>

            <h2>Actual Size Preview</h2>
            <div id="preview"></div>
            <a href="#" id="previewLink" download="image.png">Download PNG</a>
            <br /><br />

        </div>
        
    </div>

<script>
var drawChildren = function(container, children) {
    /*
    More room for cool optimizations here:
    - loop through current and desired children, compare using node types, merge differences if possible
    */
    // perhaps compare element ids

    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
    children.forEach(function(item) {
        if (item == null) {
            return;
        }
        container.appendChild(item);
    });
};

var tag = function(tagName, attributes, children) {
    var element = document.createElement(tagName);
    for (var i in attributes) {
        element.setAttribute(i, attributes[i]);
    }
    // Convert text to text node
    for (var i = 0; i < children.length; i ++) {
        var node = children[i];
        if (node == null) {
            continue;
        } else if (node instanceof Node) {
        } else {
            node = document.createTextNode(node);
        }
        element.appendChild(node);
    }

    return element;
};

var handles = {
    body: document.body,
    videos: document.getElementById('main'),
    tags: document.getElementById('tags'),

    preview: null
};

/*
KEYBOARD INPUT THOUGHTS

* would like left right arrow keys to work as seek
* page up down as faster seek

Questions

* What should advance to next/previous video? up and down arrow keys?

*/
var handlers = {
    keydown: {
        body: function(e) {
            console.log(e)
            // left arrow
            switch (e.key) {
                // backspace
                case 'Shift':
                case 'Control':
                    controls.alt = true;
                case 'Backspace':
                    e.preventDefault();
                    e.stopPropagation();
                    break;
                default:
                    console.log(e.keyCode);
                    
            }
        }
    },
    keyup: {
        body: function(e) {
            console.log(e)
            // left arrow
            switch (e.key) {
                /*
                case 'Shift':
                case 'Control':
                    controls.alt = true;
                */
                default:
                    controls.alt = false;
                    console.log(e.keyCode);
                    
            }
        }
    },
    contextmenu: {
        palette: function(e) {
            e.preventDefault();
        },
        canvas: function(e) {
            e.preventDefault(); // to prevent right-click context menu
        }
    },

    mousedown: {
        palette: function(e) {
            if (e.button == 2 || (e.button == 0 && controls.alt)) {
                cursor.color2 = controls.handles.color2.style.backgroundColor = e.target.style.backgroundColor;
            } else if (e.button == 0) {
                cursor.color1 = controls.handles.color1.style.backgroundColor = e.target.style.backgroundColor;
            }
        },
        canvas: function(e) {
            history.save();

            cursor.start = true;
            let el = e.target;
            if (e.button == 2 || (e.button == 0 && controls.alt)) {
                cursor.activeColor = cursor.color2;
            } else if (e.button == 0) {
                cursor.activeColor = cursor.color1;
            }
            if (cursor.brushType == 'fill') {
                // color cells around, too
                canvas.fill(e.target, cursor.activeColor);
            } else {
                canvas.draw(e.target, cursor.activeColor);
            }
            canvas.changed = true;
        }
    },
    mousemove: {
        canvas: function(e) {
            if (!cursor.start) {
                return;
            }
            canvas.draw(e.target, cursor.activeColor);
            canvas.changed = true;
        }
    },
    mouseup: {
        body: function(e) {
            cursor.start = false;
        }
    },
    dragstart: {
        canvas: function(e) {
            console.log('cancelling drag');
            e.preventDefault();
        }
    },

    click: {
        /*
        canvas: function(e) {
            console.log(e);
            let el = e.target;
            if (el.tagName == 'DIV' && el.parentNode && el.parentNode == canvas.handles.container) {
                e.target.style.backgroundColor = cursor.color;

            }
            
        }
        */
    }
};
// Attach the above handlers
for (var event in handlers) {
    var ids = handlers[event];
    for (var id in ids) {
        document.getElementById(id).addEventListener(event, ids[id]);
    }
}

let paletteColors = ["#472d3c","#5e3643","#7a444a","#a05b53","#bf7958","#eea160","#f4cca1","#b6d53c","#71aa34","#397b44","#3c5956","#302c2e","#5a5353","#7d7071","#a0938e","#cfc6b8","#dff6f5","#8aebf1","#28ccdf","#3978a8","#394778","#39314b","#564064","#8e478c","#cd6093","#ffaeb6","#f4b41b","#f47e1b","#e6482e","#a93b3b","#827094","#4f546b"];

let cursor = {
    color1: 'yellow',
    color2: '',
    activeColor: '',
    start: false,
    brushType: 1,

};

var square = 64;
var settings = {
    width: square,
    height: square
};

let controls = {
    zoom: 100,
    handles: {
        controls: document.getElementById('controls'),
        color1: document.getElementById('color1'),
        color2: document.getElementById('color2'),
        grid: document.getElementById('grid'),
        palette: document.getElementById('palette')
    },
    init: function() {
        let self = this;
        self.handles.controls.addEventListener('click', function(event) {
            var target = event.target;
            var action;
            // go up a level if material icon was clicked
            if (target.tagName == 'I') {
                target = target.parentNode;
            }
            action = target.getAttribute('data-action');
            // can remove this as long as we're careful
            if (action in self) {
                self[action](target, event);
            }
        });

        // let colors = [
        //     'blue',
        //     'red'
        // ];
        
        let out = [];
        out.push(
            tag('DIV', {id:'erase'}, ['X'])
        );
        paletteColors.forEach(function(color) {
            out.push(
                tag('DIV', {style: 'background-color: ' + color}, [])
            );
        });
        drawChildren(controls.handles.palette, out);
    },

    toggleGrid: function() {
        canvas.handles.container.classList.toggle('grid');
    },
    brushType: function(target) {
        let self = this;
        self.handles.controls.querySelectorAll('div').forEach(function(el) {
            el.classList.remove('selected');
        })

        target.classList.add('selected');
        
        cursor.brushType = target.getAttribute('data-value');
    },
    zoomIn: function() {
        this.zoom += 10;
        if (this.zoom > 100) {
            this.zoom = 100;
        }
        canvas.setZoom(this.zoom);
    },
    zoomOut: function() {
        this.zoom -= 10;
        if (this.zoom < 10) {
            this.zoom = 10;
        }
        
        canvas.setZoom(this.zoom);
    },
    undo: function() {
        history.undo();
    },
    redo: function() {
        history.redo();
    }
};

var canvas = {
    changed: false,
    squares: [],
    handles: {
        container: document.getElementById('canvas')
    },
    
    firstRowCutoff: null,
    lastRowCutoff: null,
    atFirstRow: function(index) {
        return index < this.firstRowCutoff;
    },
    atLastRow: function(index) {
        return index >= this.lastRowCutoff;
    },  
    atLeftEdge: function(index) {
        return (index % settings.width) == 0;
    },
    atRightEdge: function(index) {
        return (index % settings.width) == (settings.width - 1);
    },
    // this helps us draw with larger brushes
    indexToCoordinates: function(index) {
        return {
            x: index % settings.width,
            y: Math.floor(index / settings.height)
        }
    },
    coordinatesToIndex: function(x, y) {
        return x + (y * settings.height);
    },
    
    init: function() {
        this.firstRowCutoff = settings.width;
        this.lastRowCutoff = (settings.width * settings.width) - settings.width;
    
        var percentage = (100 / settings.width) + '% ';
        canvas.handles.container.style['gridTemplateColumns'] = percentage.repeat(settings.width);

        this.squares = [];
        let index = 0;
        for (let i = 0; i < settings.width; i++) {
            for (let j = 0; j < settings.width; j++) {
                this.squares.push(
                    tag('DIV', {"data-index": index}, [])
                );
                index++;
            }
        }
        drawChildren(canvas.handles.container, this.squares);
        
        this.setCellHeight();

        canvas.load();
        // set this to true to generate initial previews on page load
        canvas.changed = true;
    },
    setZoom: function(width) {
        canvas.handles.container.style.width = width + '%';
        this.setCellHeight();
    },
    setCellHeight: function() {
        let w = canvas.handles.container.childNodes[0].clientWidth;
        for (let i = 0; i < canvas.handles.container.childNodes.length; i++) {
            canvas.handles.container.childNodes[i].style['height'] = w + 'px';
        }
    },
    // TODO: rename / reword
    getPixels: function() {
        let pixels = [];
        canvas.handles.container.childNodes.forEach(function(node) {
            pixels.push( node.style.backgroundColor );
        });
        return pixels;
    },
    setPixels: function(pixels) {
        canvas.handles.container.childNodes.forEach(function(node, i) {
            node.style.backgroundColor = pixels[i];
        });
    },

    // resume
    load: function() {
        let c = localStorage.getItem('pixels');
        if (!c) {
            return;
        }
        let colors = JSON.parse(c);
        this.setPixels(colors);
    },
    save: function() {
        let out = [];
        this.handles.container.childNodes.forEach(function(node) {
            out.push( node.style.backgroundColor );
        });
        localStorage.setItem('pixels', JSON.stringify(out));
    },
    
    draw: function(el, color) {
        if (cursor.brushType == '1') {
            el.style.backgroundColor = cursor.activeColor;
            return;
        }
        let brushDeltas = {
            '3': 1,
            '5': 2
        };
        let delta = brushDeltas[cursor.brushType];


        // what does procedural code look like?
        let index = parseInt(el.getAttribute('data-index'));

        let coords = this.indexToCoordinates(index);
        let startX = Math.max(coords.x - delta, 0);
        let endX = Math.min(coords.x + delta, settings.width-1);
        let startY = Math.max(coords.y - delta, 0);
        let endY = Math.min(coords.y + delta, settings.height-1);

        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
                let i = this.coordinatesToIndex(x, y);
                this.squares[i].style.backgroundColor = cursor.activeColor;

            }
        }
    },
    
    fill: function(el, color) {
        let index = parseInt(el.getAttribute('data-index'));
        let colorToReplace = el.style.backgroundColor;
        let queue = [];
        let seen = []; // to prevent duplicate enqueueing
        let conditionalAdd = function(neighborIndex) {
            let neighbor = canvas.squares[ neighborIndex ];
            if (!seen[neighborIndex] && colorToReplace == neighbor.style.backgroundColor) {
                queue.push(neighborIndex);
                seen[neighborIndex] = true;
            }
        };

        history.save();

        queue.push(index);

        while (queue.length > 0) {
            let index = queue.shift();
            let el = this.squares[index];
            el.style.backgroundColor = color;
            if (!this.atLeftEdge(index)) {
                conditionalAdd(index - 1);
            }
            if (!this.atRightEdge(index)) {
                conditionalAdd(index + 1);
            }
            if (!this.atFirstRow(index)) {
                conditionalAdd(index - settings.width);
            }
            if (!this.atLastRow(index)) {
                conditionalAdd(index + settings.width);
            }
        }
        canvas.changed = true;
    }
};

var preview = {
    handles: {
        container: document.getElementById('preview'),
        link: document.getElementById('previewLink')
    },
    init: function() {
        // create canvas with width and height 3x the settings
        let el = tag('CANVAS', {'width': settings.width, 'height': settings.height}, []);
        this.handles.canvas = el;
        drawChildren(preview.handles.container, [el]);
    }
};

var tiled = {
    squares: [],
    handles: {
        container: document.getElementById('tiledPreview')
    },
    init: function() {
        // create canvas with width and height 3x the settings
        let el = tag('CANVAS', {'width': settings.width * 3, 'height': settings.height * 3, 'style': 'width: 500px;'}, []);
        this.handles.canvas = el;
        drawChildren(tiled.handles.container, [el]);
    }
};

let history = {
    _undo: [],
    _redo: [],

    init: function() {
        // load from localStorage into _undo and _redo
    },

    // save current state onto history/_undo
    save: function() {
        let pixels = canvas.getPixels();
        this._undo.push(pixels);

        // Clear redo/future since we've "altered" history
        this._redo = [];
    },

    undo: function() {
        let pixels;
        if (this._undo.length == 0) {
            return;
        }

        pixels = canvas.getPixels();
        this._redo.push( pixels );

        pixels = this._undo.pop();
        canvas.setPixels(pixels);

    },
    redo: function() {
        let pixels;
        if (this._redo.length == 0) {
            return;
        }

        pixels = canvas.getPixels();
        this._undo.push( pixels );
        
        pixels = this._redo.pop();
        canvas.setPixels( pixels );
    }

};


canvas.init();
controls.init();
history.init();
tiled.init();
preview.init();

setInterval(
    function() {
        if (!canvas.changed) {
            return;
        }
        canvas.save();
        canvas.changed = false;


        // Update preview and tiled preview
        let tiledCtx = tiled.handles.canvas.getContext('2d');
        let tiledImageData = tiledCtx.getImageData(0, 0, settings.width, settings.height);
        let tiledImageDataData = tiledImageData.data;

        let previewCtx = preview.handles.canvas.getContext('2d');
        let previewImageData = previewCtx.getImageData(0, 0, settings.width, settings.height);
        let previewImageDataData = previewImageData.data;

        // TODO: move this logic to canvas.save()
        let i = 0;
        canvas.handles.container.childNodes.forEach(function(node) {
            let bg = node.style.backgroundColor;
            // TODO: this might be flaky
            let parts = bg.substring(4, bg.length - 1).split(', ');

            // TODO: handle empty / transparent regions
            tiledImageDataData[i] = parseInt(parts[0]);
            tiledImageDataData[i + 1] = parseInt(parts[1]);
            tiledImageDataData[i + 2] = parseInt(parts[2]);
            tiledImageDataData[i + 3] = 255; // alpha
            i += 4;
        });

        // tile it!
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                tiledCtx.putImageData(tiledImageData, i * settings.width, j * settings.height);

            }
        }

        previewCtx.putImageData(tiledImageData, 0, 0);

        // update data url
        let url = preview.handles.canvas.toDataURL();
        preview.handles.link.href = url;
        
    },
    1000
);


</script>
</body>
</html>
